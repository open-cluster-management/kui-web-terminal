"use strict";
/*******************************************************************************
* Licensed Materials - Property of IBM
* (c) Copyright IBM Corporation 2019. All Rights Reserved.
*
* Note to U.S. Government Users Restricted Rights:
* Use, duplication or disclosure restricted by GSA ADP Schedule
* Contract with IBM Corp.
*******************************************************************************/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
exports.__esModule = true;
var React = require("react");
var _ = require("lodash");
var PropTypes = require("prop-types");
var HTTPClient_1 = require("../controller/HTTPClient");
var search_helper_1 = require("../util/search-helper");
var search_queries_1 = require("../definitions/search-queries");
var Tag_1 = require("../components/Tag");
// helper function for translations
var i18n_1 = require("../util/i18n");
var ReactTags = require('react-tag-autocomplete');
var SearchBar = /** @class */ (function (_super) {
    __extends(SearchBar, _super);
    function SearchBar(props) {
        var _this = _super.call(this, props) || this;
        _this.state = {
            suggestions: [],
            currentQuery: 'search',
            currentTag: {
                field: '',
                matchText: []
            },
            searchComplete: '',
            tags: [{
                    id: 'id-search-label',
                    key: 'key-search-label',
                    name: 'search',
                    value: 'search',
                    disabled: true
                }],
            fieldOptions: [{ id: 'loading', name: i18n_1["default"]('search.loading'), disabled: true }],
            chosenOperator: null,
            operators: ['=', '<', '>', '<=', '>=', '!=', '!']
        };
        _this.handleDelete = _this.handleDelete.bind(_this);
        _this.handleAddition = _this.handleAddition.bind(_this);
        _this.handleClearAllClick = _this.handleClearAllClick.bind(_this);
        return _this;
    }
    SearchBar.prototype.componentWillReceiveProps = function (nextProps) {
        if (!_.isEqual(nextProps.availableFilters, this.state.fieldOptions)) {
            var fields = nextProps.availableFilters && _.get(nextProps, 'availableFilters[0].id', '') !== 'failed'
                ? this.formatFields(nextProps.availableFilters)
                : [];
            var labelTag = {
                id: 'id-filter-label',
                key: 'key-filter-label',
                name: i18n_1["default"]('searchbar.filters.label'),
                value: i18n_1["default"]('searchbar.filters.label'),
                disabled: true
            };
            this.setState({
                fieldOptions: this.convertObjectToArray(fields, labelTag)
            });
        }
        if (nextProps.value === '') {
            this.setState({
                currentQuery: '',
                tags: [],
                currentTag: {
                    field: '',
                    matchText: []
                },
                searchComplete: ''
            });
        }
        else if (nextProps.value !== '' && !_.isEqual(nextProps.value, this.state.currentQuery)) {
            var tagText = nextProps.value.trim().split(' ');
            var tags_1 = tagText.map(function (tag) {
                var semicolonIdx = tag.indexOf(':');
                var f = semicolonIdx > 0 ? tag.substring(0, semicolonIdx) : tag;
                var matchText = semicolonIdx > 0 ? tag.substring(semicolonIdx + 1).split(',') : '';
                return {
                    id: "id-" + f + "-tag",
                    key: "key-" + f + "-tag",
                    classType: semicolonIdx < 1 ? 'keyword' : '',
                    name: tag,
                    value: tag,
                    field: f,
                    matchText: matchText
                };
            });
            var currentOperator = this.state.operators[this.state.operators.findIndex(function (op) { return op === tags_1[tags_1.length - 1].matchText[0]; })] || null;
            var field = ((tags_1[tags_1.length - 1].classType === 'keyword' || _.get(tags_1[tags_1.length - 1], 'matchText[0]', '') !== '') && currentOperator === null)
                ? ''
                : tags_1[tags_1.length - 1].field;
            this.setState({
                currentQuery: nextProps.value.trim(),
                searchComplete: field,
                tags: tags_1,
                chosenOperator: currentOperator || null
            });
        }
    };
    SearchBar.prototype.shouldComponentUpdate = function (nextProps, nextState) {
        if (nextState.fieldOptions.length === 1) {
            this.handleClearAllClick();
        }
        return !_.isEqual(nextProps.availableFilters, nextState.fieldOptions);
    };
    SearchBar.prototype.componentWillUpdate = function (nextProps, nextState) {
        var onChange = this.props.onChange;
        if (!_.isEqual(nextState.currentQuery, this.state.currentQuery)) {
            onChange(nextState.currentQuery);
        }
        if (!_.isEqual(nextState.currentTag, this.state.currentTag)
            && nextState.currentTag.field !== '') {
            // create new tag and add it to array
            var _a = nextState.currentTag, field = _a.field, matchText = _a.matchText, tags = nextState.tags;
            var value = matchText !== undefined ? matchText : '';
            var tagText = field + ':' + value;
            var tag = {
                id: "id-" + field + "-tag",
                key: "key-" + field + "-tag",
                name: tagText,
                value: tagText,
                field: field,
                matchText: matchText
            };
            // need to replace the tag with new one
            var tagArray = matchText.length !== 0 ? tags.slice(0, tags.length - 1) : tags;
            this.updateSelectedTags(__spread(tagArray, [tag]), nextState.currentTag);
        }
    };
    SearchBar.prototype.convertObjectToArray = function (input, label) {
        if (Array.isArray(input)) {
            input.unshift(label);
            return input;
        }
        else {
            var result_1 = [label];
            Object.values(input).forEach(function (value) {
                if (Array.isArray(value)) {
                    Object.values(value).forEach(function (element) {
                        result_1 = __spread(result_1, [element]);
                    });
                }
            });
            return result_1;
        }
    };
    SearchBar.prototype.formatFields = function (data) {
        return data.map(function (field) {
            return {
                id: "id-" + field,
                key: "key-" + field,
                name: field,
                value: field
            };
        });
    };
    SearchBar.prototype.formatSuggestionOptions = function (data) {
        var _a = this.state, chosenOperator = _a.chosenOperator, searchComplete = _a.searchComplete, tags = _a.tags;
        var labelTag = {
            id: 'id-filter-label',
            key: 'key-filter-label',
            name: i18n_1["default"]('searchbar.values.label', [searchComplete]),
            value: i18n_1["default"]('searchbar.values.label', [searchComplete]),
            disabled: true
        };
        if (searchComplete !== '' && data && data.searchComplete) {
            // Filter out previously used labels
            if (tags.length > 1) {
                var kindTag_1 = tags.slice(0, tags.length - 1).filter(function (tag) { return tag.field === searchComplete; });
                if (kindTag_1.length > 0) {
                    data.searchComplete = data.searchComplete.filter(function (value) { return kindTag_1[0].matchText.findIndex(function (item) { return item === value; }) === -1; });
                }
            }
            if (data.searchComplete.length === 0) {
                return [{
                        id: 'id-no-results',
                        name: i18n_1["default"]('searchbar.no.suggestions'),
                        disabled: true
                    }];
            }
            else {
                if (data.searchComplete[0] === 'isNumber') {
                    if (chosenOperator !== null) {
                        var rangeText = data.searchComplete.length > 2
                            ? i18n_1["default"]('searchbar.operator.range', [data.searchComplete[1], data.searchComplete[2]])
                            : i18n_1["default"]('searchbar.operator.range', [data.searchComplete[1], data.searchComplete[1]]);
                        return [
                            labelTag,
                            {
                                id: 'id-values-range',
                                key: 'key-values-range',
                                name: rangeText,
                                value: rangeText,
                                disabled: true
                            },
                        ];
                    }
                    return this.state.operators.map(function (operator) {
                        return {
                            id: "id-operators-" + operator,
                            key: "key-operators-" + operator,
                            name: operator,
                            value: operator
                        };
                    });
                }
                else if (data.searchComplete[0] === 'isDate') {
                    var dateOptions = ['hour', 'day', 'week', 'month', 'year'];
                    return this.convertObjectToArray(dateOptions.map(function (date) {
                        return {
                            id: "id-date-" + date,
                            key: "key-date-" + date,
                            name: date,
                            value: date
                        };
                    }), {
                        id: 'id-filter-label',
                        key: 'key-filter-label',
                        name: i18n_1["default"]('searchbar.operator.dateSort', [searchComplete]),
                        value: i18n_1["default"]('searchbar.operator.dateSort', [searchComplete]),
                        disabled: true
                    });
                }
                return this.convertObjectToArray(data.searchComplete.map(function (item) {
                    return {
                        id: "id-" + item,
                        key: "key-" + item,
                        name: item,
                        value: item
                    };
                }), labelTag);
            }
        }
        else {
            return [{ id: 'loading', name: i18n_1["default"]('search.loading'), disabled: true }];
        }
    };
    SearchBar.prototype.handleClearAllClick = function () {
        if (this.state.tags.length > 0) {
            this.updateSelectedTags([], {});
            this.setState({
                currentTag: {
                    field: '',
                    matchText: []
                },
                searchComplete: '',
                chosenOperator: null
            });
        }
    };
    SearchBar.prototype.handleDelete = function (i) {
        var _a = this.state, tags = _a.tags, searchComplete = _a.searchComplete;
        if (tags.length > 0) {
            if (tags[i]['matchText'] === undefined // If tag only contains a filter value
                || (tags[i]['matchText'] && tags[i]['matchText'].length <= 1) // If tag contains a filter and only 1 filter type ex: (kind:pod)
                || (tags[i]['classType'] === 'keyword' && ((tags.length > 1 && tags[i]['value'] !== 'search') || tags.length === 1 && tags[i]['value'] === 'search'))) { // dont allow deletion of search tag if there are other tags being used
                var newTags = tags.filter(function (tag, index) { return index !== i; });
                var newQuery = newTags.map(function (tag) { return tag['value']; }).join(' ');
                this.updateSelectedTags(newTags, {});
                this.setState({
                    currentQuery: newQuery
                });
                if (i !== tags.length - 1) {
                    this.setState({
                        searchComplete: searchComplete
                    });
                }
                else {
                    this.setState({
                        currentTag: {
                            field: '',
                            matchText: []
                        },
                        searchComplete: '',
                        chosenOperator: null,
                        suggestions: []
                    });
                }
            }
            else if (tags[i]['matchText'] && tags[i]['matchText'].length > 1) {
                tags[i]['matchText'].pop();
                var tagText = tags[i]['field'] + ':' + tags[i]['matchText'].join(',');
                tags[i]['name'] = tagText;
                tags[i]['value'] = tagText;
                this.updateSelectedTags(tags, {});
            }
        }
    };
    SearchBar.prototype.updateSelectedTags = function (tags, currentTag) {
        var field = currentTag.field, matchText = currentTag.matchText;
        // This block handles combining two tags with the same filter field
        var lastTag = tags[tags.length - 1];
        if (lastTag && lastTag.matchText && lastTag.matchText.length > 0 && tags.length > 1) {
            var match_1 = false;
            // see if any tags have same field
            tags = _.map(tags.slice(0, tags.length - 1), function (tag) {
                if (tag.field === lastTag.field) {
                    match_1 = true;
                    tag.matchText = _.concat(tag.matchText, lastTag.matchText);
                    var tagText = tag.field + ':' + tag.matchText.join(',');
                    tag.name = tagText;
                    tag.value = tagText;
                }
                return tag;
            });
            if (!match_1) {
                tags.push(lastTag);
            }
        }
        if (field !== '' && matchText && matchText.length > 0 && this.state.operators.findIndex(function (op) { return op === matchText[0]; }) === -1) {
            this.setState({
                currentTag: {
                    field: '',
                    matchText: []
                },
                searchComplete: '',
                chosenOperator: null,
                suggestions: []
            });
        }
        // Checks if the user has entered a space and deletes the newly created tag
        if (tags.length > 0 && (tags[tags.length - 1].name === '' || tags[tags.length - 1].name.charAt(0) === ' ')) {
            tags = tags.slice(0, tags.length - 1);
        }
        this.setState({
            currentQuery: tags.map(function (tag) { return tag.value; }).join(' '),
            tags: tags
        });
    };
    SearchBar.prototype.handleAddition = function (input) {
        var _a = this.state, fieldOptions = _a.fieldOptions, searchComplete = _a.searchComplete, tags = _a.tags, chosenOperator = _a.chosenOperator;
        if (!searchComplete && !input.id) { // Adds keyword tag
            input.classType = 'keyword';
            input.value = input.name;
            this.updateSelectedTags(__spread(tags, [input]), {});
        }
        else {
            // Adds matchText string
            if (searchComplete && input.name && this.state.operators.findIndex(function (op) { return op === input.name; }) > -1) {
                this.setState({
                    chosenOperator: input,
                    currentTag: {
                        field: searchComplete,
                        matchText: _.concat(input.name)
                    },
                    suggestions: []
                });
            }
            else if (searchComplete) {
                this.setState({
                    currentTag: {
                        field: searchComplete,
                        matchText: chosenOperator === null ? _.concat(input.name) : _.concat(chosenOperator.name + input.name)
                    },
                    chosenOperator: null
                });
            }
            else {
                // Adds field if name matches available option (name, status, etc.) otherwise keyword
                input = fieldOptions.find(function (element) { return element['name'] === input.name; });
                if (input) {
                    this.setState({ currentTag: { field: input.name, matchText: [] }, searchComplete: input.name });
                }
            }
        }
    };
    SearchBar.prototype.render = function () {
        var _this = this;
        var _a = this.state, currentQuery = _a.currentQuery, fieldOptions = _a.fieldOptions, _b = _a.searchComplete, searchComplete = _b === void 0 ? '' : _b, suggestions = _a.suggestions, tags = _a.tags;
        var query = { keywords: [], filters: [] };
        if (searchComplete !== '' && suggestions.length === 0) {
            query = search_helper_1.convertStringToQuery(currentQuery);
            query.filters = query.filters.filter(function (filter) {
                return filter.property !== searchComplete;
            });
            HTTPClient_1["default"]('post', 'search', search_queries_1.GET_SEARCH_COMPLETE(searchComplete, query))
                .then(function (res) {
                _this.setState({ suggestions: res.data });
            });
        }
        return (React.createElement("div", { className: 'tagInput-filter' },
            React.createElement("div", { className: 'tagInput-comboBox', onKeyDown: this.props.onKeyDown },
                React.createElement(ReactTags, { placeholder: '', tags: _.get(fieldOptions, '[0].id', '') === 'loading' || fieldOptions.length > 1 ? tags : undefined, suggestions: searchComplete
                        ? this.formatSuggestionOptions(suggestions)
                        : fieldOptions, handleDelete: this.handleDelete, handleAddition: this.handleAddition, tagComponent: Tag_1["default"], autoresize: false, minQueryLength: 0, allowNew: true, delimiterChars: _.get(fieldOptions, '[0].id', '') === 'loading' || fieldOptions.length > 1 ? [' ', ':', ','] : [], delimiters: [9], autofocus: true, maxSuggestionsLength: Infinity }))));
    };
    SearchBar.propTypes = {
        availableFilters: PropTypes.oneOfType([PropTypes.array, PropTypes.object]),
        onChange: PropTypes.func,
        onKeyPress: PropTypes.func,
        tags: PropTypes.array,
        value: PropTypes.string
    };
    return SearchBar;
}(React.Component));
exports["default"] = SearchBar;
