/*******************************************************************************
 * Licensed Materials - Property of IBM
 * (c) Copyright IBM Corporation 2019. All Rights Reserved.
 *
 * Note to U.S. Government Users Restricted Rights:
 * Use, duplication or disclosure restricted by GSA ADP Schedule
 * Contract with IBM Corp.
 *******************************************************************************/

const chalk = require('chalk')
const { outputSelector, successSelector, resultInputSelector, failureSelector, failureOutputSelector, failureOutputXtermSelector, clearedTerminalSelector } = require('../config/selectors')

module.exports = {
  url: function () {
    return this.api.launchUrl
  },
  elements: {
    pageLoading: '.still-loading',
    page: '.page',
    main: '.main',
    tabStripe: '.left-tab-stripe',
    commandInput: '.kui--input-stripe',
    inputBar: '.kui--input-stripe input',
    inputBarReadOnly: '.kui--input-stripe input[readonly]',
    sidecar: '#sidecar.visible',
    inputCommand: '.repl-input-element',
    commandOutput: '.repl-block[data-input-count="0"]',
    header: '#header-container',
    hamburger: '#hamburger',
    leftNav: '#left-nav',
    newTabBtn: '.kui-new-tab__plus'
  },
  commands: [{
    waitForPageLoad,
    verifyWebsocketConnection,
    executeCommand,
    verifyOutputSuccess,
    verifyOutputFailure,
    verifyGettingStarted,
    verifyErrorMessage,
    verifyOutputMessage,
    verifyTheme,
    verifyProductHeader,
    verifyNewTabs,
    verifyDetailSidecar,
    verifyReverseISearch,
    clear
  }]
}

function waitForPageLoad(browser) {
  this.api.pause(5000)
    // The acceptInsecuretCerts config for Firefox doesn't work, so we have to click and accept
    this.api.element('css selector', '#errorPageContainer', res => {
      if (res.status !== -1) {
        this.waitForElementPresent('#advancedButton').press('#advancedButton')
        this.waitForElementPresent('#exceptionDialogButton').click('#exceptionDialogButton')
        this.waitForElementNotPresent('#errorPageContainer')
      }
      browser.element('css selector', '.page', res => {
        this.waitForElementNotPresent('@pageLoading', 60000)
        this.waitForElementPresent('@page', 20000)
        this.waitForElementPresent('@main')
        this.waitForElementPresent('@tabStripe')
      })
    })
}

function verifyWebsocketConnection(browser) {
  this.waitForElementPresent(successSelector, 60000)
  browser.assert.isCommand("ready")
}

function verifyErrorMessage(browser, message, isXterm) {
  const selector = isXterm ? failureOutputXtermSelector : failureOutputSelector
  this.waitForElementPresent(selector, 60000)
  browser.expect.element(selector).text.to.equal(message)
}

function executeCommand(browser, command, failed) {
  browser.perform(() => console.log(chalk.bold.yellow('EXECUTING: ') + chalk.bold.cyan(command)))
  
  this.api.page.KUI().clear()

  this.setValue('@inputBar', command) // input command
  this.waitForElementPresent(`.kui--input-stripe input[value="${command}"]`)

  this.enter()

  this.waitForElementPresent(outputSelector, 20000)
  this.waitForElementNotPresent('@inputBarReadOnly', 60000)

  this.waitForElementPresent(resultInputSelector, 10000)
  browser.assert.isCommand(command)

  failed ? this.waitForElementPresent(failureSelector, 20000) : this.waitForElementPresent(successSelector, 20000)
}

function verifyOutputSuccess(browser) {
  browser.assert.cssProperty(outputSelector + ' .kui--icon-error', 'display', 'none')
}

function verifyOutputFailure(browser) {
  browser.assert.cssProperty(outputSelector + ' .kui--icon-error', 'display', 'block')
}

function verifyOutputMessage(browser, message, regexMsg) {
  const preMsgSelector = outputSelector + ' .repl-result pre'
  const xtermMsgSelector = outputSelector + ' .xterm-container .xterm-rows div:first-of-type'
  this.api.element('css selector', preMsgSelector, preRes => {
    if (preRes.status === 0) { // output is returned in a pre element
      browser.assert.containsText(preMsgSelector, message)
    } else {
      this.api.elements('css selector', xtermMsgSelector, xtermRes => {
        if (xtermRes.status === 0) { // output is returned xterm container one span per letter
          let msgText = ''
          xtermRes.value.forEach(element => this.api.elementIdText(element.ELEMENT, text => msgText += text.value + '\n'))
          browser.perform(() => {
            if((message && !msgText.includes(message)) || (regexMsg && !msgText.match(regexMsg))) {
              throw new Error(`${msgText} did not contain the text: "${message?message:regexMsg}"`)
            }
          })
        }
      })
    }
  })
}

function verifyTheme(browser, theme) {
  const { name } = theme
  const themeButton = successSelector + ` span[title="${name}"]`
  this.waitForElementPresent(themeButton)
  this.press(themeButton)
  this.waitForElementPresent(`body[kui-theme="${name}"]`)
}

function verifyProductHeader() {
  const hamburger = '#hamburger'
  this.waitForElementPresent('@header')
  this.waitForElementPresent('@hamburger')
  this.press(hamburger)
  this.waitForElementPresent('@leftNav')
  this.press(hamburger)
  this.waitForElementNotPresent('@leftNav')
}

function verifyNewTabs(browser) {
  const KUI = browser.page.KUI()
  const firstTab = '.left-tab-stripe-buttons .kui-tab:nth-of-type(1)'
  const secondTab = '.left-tab-stripe-buttons .kui-tab:nth-of-type(2)'
  const firstTabContainer = '.tab-container tab:nth-of-type(1)'
  const secondTabContainer = '.tab-container tab:nth-of-type(2)'
  const tabCloseBtn = ' .left-tab-stripe-button-closer svg'
  this.waitForElementPresent('@newTabBtn')
  this.press('.kui-new-tab__plus') // open new tab
  this.waitForElementPresent(secondTab)
  this.waitForElementPresent(secondTabContainer)
  this.assert.cssProperty(firstTabContainer, 'display', 'none')
  KUI.verifyWebsocketConnection(browser) // verify websocket connects on new tab
  browser.assert.cssClassPresent(secondTab, 'kui-tab--active') // verify active tab
  browser.assert.cssClassNotPresent(firstTab, 'kui-tab--active')
  this.press(firstTab) // go back to first tab
  this.waitForElementPresent(firstTabContainer)
  this.assert.cssProperty(secondTabContainer, 'display', 'none')
  browser.assert.cssClassPresent(firstTab, 'kui-tab--active')
  browser.assert.cssClassNotPresent(secondTab, 'kui-tab--active')
  this.press(secondTab + tabCloseBtn) // close the second tab
  this.waitForElementNotPresent(secondTab)
  this.waitForElementNotPresent(secondTabContainer)
}

// Getting Started sidecar content
function verifyGettingStarted() {
  const tabs = ['about', 'gettingStarted', 'configure']
  tabs.forEach(tab => this.waitForElementPresent(`.bx--tabs li[data-mode="${tab}"]`))
}

//Drill down sidecar when selecting an element in a table
function verifyDetailSidecar(browser) {
  const firstTableResult = '.repl-block[data-input-count="0"] tbody.entity span.entity-name'
  this.api.pause(500)
  browser.press(firstTableResult)
  this.waitForElementPresent('@sidecar', 30000)
  browser.getText('#sidecar .sidecar-header-name-content span.entity-name', res => {
    // Compare the sidecar title with the table row name clicked
    browser.assert.containsText(firstTableResult, res.value)
  })
  browser.press('#sidecar .sidecar-bottom-stripe-quit path')
}

function verifyReverseISearch(browser, command, search) {
  // We need a ctrl key + r combination
  const keyConfig = { ctrlKey: true, keyCode: 82, which: 82  }
  const risElement = '.repl-temporary.normal-text.monospace span.small-right-pad'
  const matchSelector = `.repl-input-like[data-full-match="${command}"]`
  this.keyCombo('.kui--input-stripe input', 'keyup', keyConfig)
  this.setValue('@inputBar', search) // enter reverse i search parameter
  this.waitForElementPresent(risElement)
  this.assert.containsText(risElement, 'reverse-i-search')
  this.waitForElementPresent(matchSelector)

  this.client.api.execute(function () {
    const enter = new KeyboardEvent('keypress', { bubbles: false, cancelable: true, keyCode: 13 });
    const element = document.querySelector('.kui--input-stripe input');
    element.dispatchEvent(enter);
  }, [], () => {})
}

function clear() {
  this.waitForElementPresent('@commandInput')
  this.waitForElementPresent('@inputBar')
  this.waitForElementNotPresent('@inputBarReadOnly', 60000)

  this.enter()

  this.clearValue('@inputBar')
  this.waitForElementPresent('.kui--input-stripe input[value]')
  this.setValue('@inputBar', 'clear') // clean output
  this.waitForElementPresent('.kui--input-stripe input[value="clear"]')

  const { browserName } = this.api.options.desiredCapabilities
  browserName === 'safari' && this.api.pause(250)

  this.enter()
  this.waitForElementPresent(clearedTerminalSelector, 20000)
  this.waitForElementNotPresent('@inputBarReadOnly', 60000)

  this.clearValue('@inputBar')
  this.waitForElementPresent('.kui--input-stripe input[value]')
}

