declare type NodeType = 'sequence' | 'seq' | 'on' | 'map' | 'forall' | 'par' | 'parallel' | 'finally' | 'literal' | 'value' | 'let' | 'repeat' | 'retain' | 'retry' | 'dowhile' | 'dowhile_nosave' | 'while' | 'while_nosave' | 'try' | 'empty' | 'if' | 'function' | 'action';
export interface ASTNode {
    type: NodeType;
}
export interface ValueBearing extends ASTNode {
    value: any;
}
export interface Literal extends ValueBearing {
    type: 'literal' | 'value';
}
export declare function isLiteral(ast: ASTNode): ast is Literal;
export interface ComponentBearing<ComponentType = ASTNode> extends ASTNode {
    components: ComponentType;
}
export interface Conditional extends ASTNode {
    test: ASTNode;
    consequent: ASTNode;
    alternate: ASTNode;
}
export declare function isConditional(ast: ASTNode): ast is Conditional;
export interface BodyBearing extends ASTNode {
    body: ASTNode;
}
export interface TestBearing extends BodyBearing {
    test: ASTNode;
}
export interface While extends TestBearing {
    type: 'while' | 'while_nosave';
}
export declare function isWhile(ast: ASTNode): ast is While;
export interface DoWhile extends TestBearing {
    type: 'dowhile' | 'dowhile_nosave';
}
export declare function isDoWhile(ast: ASTNode): ast is DoWhile;
export interface Try extends BodyBearing {
    type: 'try';
    handler: ASTNode;
}
export declare function isTry(ast: ASTNode): ast is Try;
export interface Action extends ASTNode {
    type: 'action';
    name: string;
    displayLabel?: string;
}
export declare function isAction(ast: ASTNode): ast is Action;
export interface Function extends ASTNode {
    function: {
        exec: {
            code: string;
            prettyCode?: string;
        };
    };
}
export declare function isFunction(ast: ASTNode): ast is Function;
export interface Finally extends BodyBearing {
    type: 'finally';
    finalizer: ASTNode;
}
export declare function isFinally(ast: ASTNode): ast is Finally;
export interface On extends ComponentBearing {
    type: 'on';
    trigger: string;
}
export declare function isOn(ast: ASTNode): ast is On;
export interface RetryOrRepeat extends ComponentBearing {
    type: 'retry' | 'repeat';
    count: string;
}
export declare function isRetryOrRepeat(ast: ASTNode): ast is RetryOrRepeat;
export interface Let extends ComponentBearing {
    type: 'let';
    declarations: string;
}
export declare function isLet(ast: ASTNode): ast is Let;
export declare function isSequence(ast: ASTNode): ast is ComponentBearing;
export declare function isRetain(ast: ASTNode): ast is ComponentBearing;
export declare function isComponentBearing(ast: ASTNode): ast is ComponentBearing;
export interface ComponentArrayBearing<ComponentType = ASTNode> extends ASTNode {
    components: ComponentType[];
}
export declare function isComponentArrayBearing(ast: ASTNode): ast is ComponentArrayBearing;
export interface ParallelLike extends ComponentArrayBearing {
    type: 'parallel' | 'par' | 'map' | 'forall';
    set?: ASTNode;
}
export declare function isParallelLike(ast: ASTNode): ast is ParallelLike;
export interface MapLike extends ASTNode {
    type: 'map' | 'forall';
    components?: ASTNode;
    body?: ASTNode;
}
export declare function isMapLike(ast: ASTNode): ast is MapLike;
export {};
