/*
 * Copyright 2020 IBM Corporation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { CLI, Common, ReplExpect, Selectors, SidecarExpect } from '@kui-shell/test';
import { defaultModeForGet, waitForGreen } from '@kui-shell/plugin-kubectl/tests/lib/k8s/utils';
export function create(ns, inputEncoded, podName) {
    it(`should create sample pod from URL`, () => {
        return CLI.command(`echo ${inputEncoded} | base64 --decode | kubectl create -f - -n ${ns}`, this.app)
            .then(ReplExpect.okWithPtyOutput(podName))
            .catch(Common.oops(this, true));
    });
}
export function wait(ns, podName, splitIndex) {
    if (process.env.USE_WATCH_PANE) {
        it(`should wait for the pod to come up`, () => {
            return CLI.command(`kubectl get pod ${podName} -n ${ns} -w`, this.app)
                .then(() => __awaiter(this, void 0, void 0, function* () {
                yield this.app.client.waitForExist(Selectors.CURRENT_GRID_ONLINE_FOR_SPLIT(splitIndex, podName));
            }))
                .catch(Common.oops(this, true));
        });
    }
    else {
        it(`should wait for the pod to come up`, () => {
            return CLI.command(`kubectl get pod ${podName} -n ${ns} -w`, this.app)
                .then(ReplExpect.okWithCustom({ selector: Selectors.BY_NAME(podName) }))
                .then(selector => waitForGreen(this.app, selector))
                .catch(Common.oops(this, true));
        });
    }
}
export function get(ns, podName, wait = true) {
    it(`should get pod ${podName} via kubectl then click`, () => __awaiter(this, void 0, void 0, function* () {
        try {
            const selector = yield CLI.command(`kubectl get pods ${podName} -n ${ns}`, this.app).then(ReplExpect.okWithCustom({ selector: Selectors.BY_NAME(podName) }));
            if (wait) {
                // wait for the badge to become green
                yield waitForGreen(this.app, selector);
            }
            // now click on the table row
            yield this.app.client.click(`${selector} .clickable`);
            yield SidecarExpect.open(this.app)
                .then(SidecarExpect.mode(defaultModeForGet))
                .then(SidecarExpect.showing(podName));
        }
        catch (err) {
            return Common.oops(this, true)(err);
        }
    }));
}
export function clickRetry() {
    return __awaiter(this, void 0, void 0, function* () {
        yield this.app.client.waitForVisible(Selectors.SIDECAR_MODE_BUTTON('retry-streaming'));
        yield this.app.client.click(Selectors.SIDECAR_MODE_BUTTON('retry-streaming'));
    });
}
function waitUntilPreviousIs(type, previous) {
    return __awaiter(this, void 0, void 0, function* () {
        const click = clickRetry.bind(this);
        yield this.app.client.waitUntil(() => __awaiter(this, void 0, void 0, function* () {
            if (!this.app.client.isExisting(Selectors.SIDECAR_TOOLBAR_TEXT(type))) {
                yield click();
                return false;
            }
            else {
                return true;
            }
        }));
        yield SidecarExpect.toolbarText({ type, text: previous ? 'previous instance' : '' });
    });
}
export function logs(ns, podName, containerName, type, previous) {
    const wait = waitUntilPreviousIs.bind(this, type, previous);
    it(`should get logs for ${podName} with previous=${previous} via command`, () => __awaiter(this, void 0, void 0, function* () {
        try {
            yield CLI.command(`kubectl logs ${podName} -c ${containerName} -n ${ns} ${previous ? '--previous' : ''}`, this.app)
                .then(ReplExpect.justOK)
                .then(SidecarExpect.open)
                .then(SidecarExpect.showing(podName, undefined, undefined, ns))
                .then(SidecarExpect.mode('logs'));
            yield wait();
        }
        catch (err) {
            yield Common.oops(this, true);
        }
    }));
}
export function clickPrevious(type, previous) {
    const wait = waitUntilPreviousIs.bind(this, type, previous);
    it(`should click the previous toggle button and expect previous=${previous}`, () => __awaiter(this, void 0, void 0, function* () {
        const mode = 'kubectl-logs-previous-toggle';
        yield this.app.client.waitForVisible(Selectors.SIDECAR_MODE_BUTTON(mode));
        yield this.app.client.click(Selectors.SIDECAR_MODE_BUTTON(mode));
        yield wait();
    }));
}
//# sourceMappingURL=helpers.js.map