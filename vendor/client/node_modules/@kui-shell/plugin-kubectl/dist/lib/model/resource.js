"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hasResourceVersion = hasResourceVersion;
exports.sameResourceVersion = sameResourceVersion;
exports.hasSingleOwnerReference = hasSingleOwnerReference;
exports.hasRawData = hasRawData;
exports.isNamespaced = isNamespaced;
exports.isKubeResource = isKubeResource;
exports.isKubeResourceWithItsOwnSummary = isKubeResourceWithItsOwnSummary;
exports.isSummarizableKubeResource = isSummarizableKubeResource;
exports.isRole = isRole;
exports.isRoleBinding = isRoleBinding;
exports.isServiceAccount = isServiceAccount;
exports.isPod = isPod;
exports.isNamespace = isNamespace;
exports.isJob = isJob;
exports.isDeployment = isDeployment;
exports.isReplicaSet = isReplicaSet;
exports.hasInvolvedObject = hasInvolvedObject;
exports.isEvent = isEvent;
exports.isCrudableKubeResource = isCrudableKubeResource;
exports.isKubeItems = isKubeItems;
exports.isKubeItemsOfKind = isKubeItemsOfKind;
exports.isCustomResourceDefinition = isCustomResourceDefinition;
exports.isConfigMap = isConfigMap;
exports.isClusterScoped = isClusterScoped;
exports.isNode = isNode;
exports.DefaultKubeMetadata = exports.DefaultKubeStatus = void 0;

var _apiVersion = _interopRequireDefault(require("../../controller/kubectl/apiVersion"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * Copyright 2018-19 IBM Corporation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DefaultKubeStatus {
  constructor() {
    this.message = undefined;
  }

}

exports.DefaultKubeStatus = DefaultKubeStatus;

function hasResourceVersion(resource) {
  const withVersion = resource;
  return typeof withVersion.metadata.resourceVersion === 'string';
}

function sameResourceVersion(a, b) {
  return a.apiVersion === b.apiVersion && a.kind === b.kind && a.metadata.name === b.metadata.name && a.metadata.namespace === b.metadata.namespace && hasResourceVersion(a) && hasResourceVersion(b) && a.metadata.resourceVersion === b.metadata.resourceVersion;
}

function hasSingleOwnerReference(resource) {
  if (!resource.metadata) {
    return false;
  }

  const {
    ownerReferences
  } = resource.metadata;
  return ownerReferences && Array.isArray(ownerReferences) && ownerReferences.length === 1 && typeof ownerReferences[0].apiVersion === 'string' && typeof ownerReferences[0].kind === 'string' && typeof ownerReferences[0].name === 'string';
}

class DefaultKubeMetadata {
  constructor() {
    this.kind = undefined;
    this.name = undefined;
  }

}

exports.DefaultKubeMetadata = DefaultKubeMetadata;

function hasRawData(resource) {
  const withData = resource;
  return typeof withData.kuiRawData === 'string';
}
/** is the resource Namespaced? */


function isNamespaced(resource) {
  return resource.metadata !== undefined && resource.metadata.namespace !== undefined;
}
/** is the command response a Kubernetes resource? note: excluding any ones we simulate in kubeui */


function isKubeResource(entity) {
  const kube = entity;
  return kube !== undefined && kube.isKubeResource === true && kube.apiVersion !== undefined && kube.apiVersion !== _apiVersion.default && kube.kind !== undefined;
}

function isKubeResourceWithItsOwnSummary(resource) {
  return resource !== undefined && resource.summary !== undefined;
}
/**
 * This allows us to exclude certain resource kinds from auto-summarization
 *
 */


function isSummarizableKubeResource(resource) {
  return isKubeResource(resource) && (isKubeResourceWithItsOwnSummary(resource) || resource.kind !== undefined && resource.kind !== 'List' && resource.kind !== 'CustomResourceDefinition');
}

function isRole(resource) {
  const role = resource;
  return role.rules !== undefined;
}

function isRoleBinding(resource) {
  const rb = resource;
  return rb.roleRef !== undefined && rb.subjects !== undefined;
}

function isServiceAccount(resource) {
  const sa = resource;
  return isKubeResource(resource) && sa.secrets !== undefined;
}
/**
 * @return whether the given resource is an instance of a Pod
 *
 */


function isPod(resource) {
  return isKubeResource(resource) && resource.apiVersion === 'v1' && resource.kind === 'Pod';
}
/**
 * @return whether the given resource is an instance of a Namespace
 *
 */


function isNamespace(resource) {
  return isKubeResource(resource) && resource.apiVersion === 'v1' && resource.kind === 'Namespace';
}
/**
 * @return whether the given resource is an instance of a Deploymemt
 *
 */


function isJob(resource) {
  return isKubeResource(resource) && resource.apiVersion === 'batch/v1' && resource.kind === 'Job';
}
/**
 * @return whether the given resource is an instance of a Deployment
 *
 */


function isDeployment(resource) {
  return isKubeResource(resource) && resource.apiVersion === 'extensions/v1beta1' && resource.kind === 'Deployment';
}
/**
 * @return whether the given resource is an instance of a ReplicaSet
 *
 */


function isReplicaSet(resource) {
  return isKubeResource(resource) && resource.apiVersion === 'extensions/v1beta1' && resource.kind === 'ReplicaSet';
}

function hasInvolvedObject(resource) {
  const io = resource;
  return io.involvedObject !== undefined && typeof io.involvedObject.apiVersion === 'string' && typeof io.involvedObject.kind === 'string' && typeof io.involvedObject.name === 'string';
}
/**
 * @return whether the given resource is an instance of an Event
 *
 */


function isEvent(resource) {
  return isKubeResource(resource) && resource.apiVersion === 'v1' && resource.kind === 'Event';
}
/** is the command response a kube resource that can responds to "kubectl delete", etc.? */


function isCrudableKubeResource(entity) {
  return isKubeResource(entity) && !isEvent(entity) && !entity.isSimulacrum;
}

function isKubeItems(resource) {
  return isKubeResource(resource) && resource.apiVersion === 'v1' && resource.kind === 'List';
}

function isKubeItemsOfKind(resource, isOfKind) {
  return isKubeItems(resource) && resource.items.length > 0 && isOfKind(resource.items[0]);
}
/**
 * @return whether the given resource is an instance of a CustomResourceDefinition
 *
 */


function isCustomResourceDefinition(resource) {
  return isKubeResource(resource) && (resource.apiVersion === 'apiextensions.k8s.io/v1' || resource.apiVersion === 'apiextensions.k8s.io/v1beta1') && resource.kind === 'CustomResourceDefinition';
}
/**
 * @return whether the given resource is an instance of a CustomResourceDefinition
 *
 */


function isConfigMap(resource) {
  return isKubeResource(resource) && resource.apiVersion === 'v1' && resource.kind === 'ConfigMap';
}
/**
 * Is the given resource kind cluster scoped (as opposed to namespace scoped)?
 * FIXME: apiVersion
 */


function isClusterScoped(kind) {
  return kind === 'CustomResourceDefinition' || kind === 'Namespace' || kind === 'Node';
}

function isNode(resource) {
  return resource.apiVersion === 'v1' && resource.kind === 'Node';
}