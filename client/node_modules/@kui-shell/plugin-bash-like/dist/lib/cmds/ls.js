"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const debug_1 = require("debug");
const fs_1 = require("fs");
const path_1 = require("path");
const core_1 = require("@kui-shell/core");
const bash_like_1 = require("./bash-like");
const usage_helpers_1 = require("../util/usage-helpers");
const strings = core_1.i18n('plugin-bash-like');
const debug = debug_1.default('plugins/bash-like/cmds/ls');
const scanForFilename = (str, fileMap, endIdx = str.length - 1) => {
    let candidate;
    let candidateIdx;
    for (let idx = endIdx; idx >= 0; idx--) {
        const maybe = str.slice(idx, endIdx + 1);
        if (fileMap[maybe]) {
            if (!candidate || candidate.length < maybe.length) {
                candidate = maybe;
                candidateIdx = idx - 1;
            }
        }
    }
    if (candidate) {
        fileMap[candidate] = false;
        return candidateIdx;
    }
};
const myreaddir = (dir) => new Promise((resolve, reject) => {
    const toMap = (files) => {
        return files.reduce((M, file) => {
            M[file] = true;
            M[path_1.join(dir, file)] = true;
            return M;
        }, {});
    };
    fs_1.lstat(dir, (err, stats) => {
        if (err) {
            if (err.code === 'ENOENT') {
                const parent = path_1.dirname(dir);
                if (parent) {
                    return myreaddir(path_1.dirname(dir))
                        .then(resolve)
                        .catch(reject);
                }
            }
            reject(err);
        }
        else if (!stats.isDirectory()) {
            resolve(toMap([dir]));
        }
        else {
            fs_1.readdir(dir, (err, files) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(toMap(['.', '..'].concat(files)));
                }
            });
        }
    });
});
const lsOrOpen = ({ argvNoOptions, REPL }) => __awaiter(void 0, void 0, void 0, function* () {
    const filepath = argvNoOptions[argvNoOptions.indexOf('lsOrOpen') + 1];
    const stats = (yield REPL.rexec(`fstat ${REPL.encodeComponent(filepath)}`)).content;
    const filepathForRepl = REPL.encodeComponent(filepath);
    if (stats.isDirectory) {
        return REPL.pexec(`ls ${filepathForRepl}`);
    }
    else {
        return REPL.pexec(`${stats.viewer} ${filepathForRepl}`);
    }
});
const fstat = ({ argvNoOptions, parsedOptions }) => {
    return new Promise((resolve, reject) => {
        const filepath = argvNoOptions[1];
        const { resolved: fullpath, viewer = 'open' } = core_1.findFileWithViewer(core_1.expandHomeDir(filepath));
        debug('fullpath', fullpath, filepath, core_1.expandHomeDir(filepath));
        const prettyFullPath = fullpath.replace(new RegExp(`^${process.env.HOME}`), '~');
        fs_1.stat(fullpath, (err, stats) => {
            if (err) {
                if (err.code === 'ENOENT') {
                    const error = new Error(err.message);
                    error.stack = err.stack;
                    error.code = 404;
                    reject(error);
                }
                else {
                    reject(err);
                }
            }
            else if (stats.isDirectory() || !parsedOptions['with-data']) {
                resolve({
                    mode: 'raw',
                    content: {
                        viewer,
                        filepath,
                        fullpath: prettyFullPath,
                        isDirectory: stats.isDirectory()
                    }
                });
            }
            else {
                fs_1.readFile(fullpath, (err, data) => {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve({
                            mode: 'raw',
                            content: {
                                viewer,
                                filepath,
                                fullpath: prettyFullPath,
                                data: data.toString(),
                                isDirectory: false
                            }
                        });
                    }
                });
            }
        });
    });
};
const tabularize = (cmd, { REPL, parsedOptions }, parent = '', parentAsGiven = '') => (output) => __awaiter(void 0, void 0, void 0, function* () {
    if (output.length === 0) {
        debug('tabularize empty');
        return true;
    }
    const fileMap = yield myreaddir((parent || process.cwd()).replace(/['"]/g, ''));
    const startIdx = output.match(/^total [\d]+/) ? 1 : 0;
    const columnGap = process.platform === 'darwin' ? 15 : 1;
    const rows = output
        .split(/[\n\r]/)
        .slice(startIdx)
        .map(line => line
        .split(new RegExp(`[\\s]{${columnGap}}`))
        .map(col => col.trim())
        .filter(x => x)
        .map((col, idx, A) => {
        if (idx === 1) {
            const spaceIdx = col.indexOf(' ');
            return [col.substring(0, spaceIdx), col.substring(spaceIdx + 1)].filter(x => x);
        }
        else if (process.platform !== 'darwin' && idx >= 5 && idx <= 7) {
            if (idx === 5) {
                return `${A[idx]} ${A[idx + 1]} ${A[idx + 2]}`;
            }
        }
        else if (process.platform === 'darwin' && idx === 3) {
            const spaceIdx1 = col.indexOf(' ');
            const stats = A[0];
            const isLink = stats.charAt(0) === 'l';
            if (isLink) {
                const arrow = '->';
                const arrowIdx = col.lastIndexOf(arrow);
                const endOfLinkIdx = arrowIdx - arrow.length + 1;
                const startOfFilename = scanForFilename(col, fileMap, endOfLinkIdx - 1);
                return [
                    col.substring(0, spaceIdx1),
                    col.substring(spaceIdx1 + 1, startOfFilename),
                    col.substring(startOfFilename + 1, endOfLinkIdx)
                ];
            }
            else {
                const startOfFilename = scanForFilename(col, fileMap);
                return [
                    col.substring(0, spaceIdx1),
                    col.substring(spaceIdx1 + 1, startOfFilename),
                    col.substring(startOfFilename + 1)
                ];
            }
        }
        else if (process.platform !== 'darwin' && idx >= 8) {
            if (idx === 8) {
                const stats = A[0];
                const isLink = stats.charAt(0) === 'l';
                const rest = A.slice(idx).join(' ');
                if (isLink) {
                    const arrow = '->';
                    const arrowIdx = rest.lastIndexOf(arrow);
                    return rest.slice(0, arrowIdx).trim();
                }
                else {
                    return rest;
                }
            }
        }
        else {
            return col;
        }
    }))
        .map(core_1.flatten)
        .map(row => row.filter(x => x))
        .filter(x => x.length > 0)
        .filter(row => !row[row.length - 1].match(/~$/));
    const outerCSS = 'header-cell';
    const outerCSSSecondary = `${outerCSS} hide-with-sidecar`;
    const ownerAttrs = !parsedOptions.l
        ? []
        : [
            { key: 'owner', value: 'OWNER', outerCSS: outerCSSSecondary },
            { key: 'group', value: 'GROUP', outerCSS: outerCSSSecondary }
        ];
    const permissionAttrs = !parsedOptions.l
        ? []
        : [
            {
                key: 'permissions',
                value: 'PERMISSIONS',
                outerCSS: outerCSSSecondary
            }
        ];
    const normalAttrs = [
        { key: 'size', value: 'SIZE', outerCSS: outerCSSSecondary },
        {
            key: 'lastmod',
            value: 'LAST MODIFIED',
            outerCSS: `${outerCSS} badge-width`
        }
    ];
    const headerAttributes = permissionAttrs.concat(ownerAttrs).concat(normalAttrs);
    const headerRow = {
        name: 'NAME',
        type: 'file',
        onclick: false,
        outerCSS,
        attributes: headerAttributes
    };
    const body = rows.map((columns) => {
        const stats = columns[0];
        const isDirectory = stats.charAt(0) === 'd';
        const isLink = stats.charAt(0) === 'l';
        const isExecutable = stats.indexOf('x') > 0;
        const isSpecial = stats.charAt(0) !== '-';
        const name = columns[columns.length - 1];
        const nameForDisplay = `${name}${isDirectory ? '/' : isLink ? '@' : isExecutable ? '*' : ''}`;
        const css = isDirectory
            ? 'dir-listing-is-directory'
            : isLink
                ? 'dir-listing-is-link'
                : isExecutable
                    ? 'dir-listing-is-executable'
                    : isSpecial
                        ? 'dir-listing-is-other-special'
                        : '';
        const startTrim = 2;
        const endTrim = 0;
        const allTrim = startTrim + endTrim + 1;
        const ownerIdx = 1 - 1;
        const groupIdx = 2 - 1;
        const sizeIdx = 3 - 1;
        const dateIdx = columns.length - allTrim - 1;
        const sortByTime = parsedOptions.t;
        const permissionAttrs = !parsedOptions.l
            ? []
            : [
                {
                    value: columns[0],
                    css: 'slightly-deemphasize'
                }
            ];
        const normalAttributes = columns
            .slice(startTrim, columns.length - endTrim - 1)
            .map((col, idx) => {
            if (parsedOptions.l || (idx !== ownerIdx && idx !== groupIdx)) {
                return {
                    value: col,
                    outerCSS: idx !== dateIdx ? 'hide-with-sidecar' : 'badge-width',
                    css: idx === ownerIdx ||
                        idx === groupIdx ||
                        (idx === dateIdx && !sortByTime) ||
                        (idx === sizeIdx && sortByTime)
                        ? 'slightly-deemphasize'
                        : ''
                };
            }
        })
            .filter(x => x);
        return new core_1.Row({
            type: cmd,
            name: nameForDisplay,
            onclickExec: 'qexec',
            onclick: `lsOrOpen ${REPL.encodeComponent(path_1.isAbsolute(name) ? name : path_1.join(parentAsGiven, name))}`,
            css,
            attributes: permissionAttrs.concat(normalAttributes)
        });
    });
    return new core_1.Table({
        style: core_1.TableStyle.Light,
        noEntityColors: true,
        noSort: true,
        header: headerRow,
        body
    });
});
const doLs = (cmd) => (opts) => __awaiter(void 0, void 0, void 0, function* () {
    const semi = yield opts.REPL.semicolonInvoke(opts);
    if (semi) {
        debug('ls with semi', semi);
        return semi;
    }
    const { command, execOptions, argvNoOptions: argv } = opts;
    const filepathAsGiven = argv[argv.indexOf(cmd) + 1];
    const filepath = core_1.findFile(core_1.expandHomeDir(filepathAsGiven), {
        safe: true,
        keepRelative: true
    });
    if (filepath.match(/app.asar/) && core_1.isSpecialDirectory(filepathAsGiven)) {
        throw new Error('File not found');
    }
    const rest = command.replace(/^\s*(l)?ls/, '').replace(filepathAsGiven, filepath);
    return bash_like_1.doExec(`ls -lh ${rest}`, Object.assign({}, execOptions, {
        nested: true,
        raw: true,
        env: {
            LS_COLWIDTHS: '100:100:100:100:100:100:100:100'
        }
    })).then(tabularize(command, opts, filepath, filepathAsGiven));
});
const usage = (command) => ({
    command,
    title: strings('lsUsageTitle'),
    header: strings('lsUsageHeader'),
    noHelpAlias: true,
    optional: usage_helpers_1.localFilepath.concat([
        { name: '-A', boolean: true, docs: strings('lsDashAUsageDocs') },
        {
            name: '-a',
            boolean: true,
            docs: strings('lsDashaUsageDocs')
        },
        {
            name: '-c',
            boolean: true,
            docs: strings('lsDashcUsageDocs')
        },
        { name: '-l', boolean: true, hidden: true },
        { name: '-h', boolean: true, hidden: true },
        {
            name: '-t',
            boolean: true,
            docs: strings('lsDashtUsageDocs')
        },
        { name: '-r', boolean: true, docs: strings('lsDashrUsageDocs') },
        { name: '-s', boolean: true, hidden: true },
        { name: '-S', boolean: true, docs: strings('lsDashSUsageDocs') }
    ])
});
exports.default = (commandTree) => {
    commandTree.listen('/fstat', fstat, {
        hidden: true,
        noAuthOk: true,
        requiresLocal: true
    });
    commandTree.listen('/lsOrOpen', lsOrOpen, {
        hidden: true,
        noAuthOk: true,
        inBrowserOk: true
    });
    const ls = commandTree.listen('/ls', doLs('ls'), {
        usage: usage('ls'),
        noAuthOk: true,
        requiresLocal: true
    });
    commandTree.synonym('/lls', doLs('lls'), ls, {
        usage: usage('lls'),
        noAuthOk: true,
        requiresLocal: true
    });
};
//# sourceMappingURL=ls.js.map