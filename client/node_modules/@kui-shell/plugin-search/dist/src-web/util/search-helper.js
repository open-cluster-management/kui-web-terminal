"use strict";
/*******************************************************************************
 * Licensed Materials - Property of IBM
 * (c) Copyright IBM Corporation 2019. All Rights Reserved.
 *
 * Note to U.S. Government Users Restricted Rights:
 * Use, duplication or disclosure restricted by GSA ADP Schedule
 * Contract with IBM Corp.
 *******************************************************************************/
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
exports.__esModule = true;
exports.convertStringToQuery = function (searchText) {
    var searchTokens;
    var search = searchText.split(' ');
    if (searchText.indexOf(search[0] + " summary ") !== -1) { // This will allow the alias for search to access the searchTokens for the command.
        searchTokens = searchText.replace(search[0] + " summary ", '').split(' ');
    }
    else if (searchText.indexOf(search[0] + " related:resources ") !== -1) {
        searchTokens = searchText.replace(search[0] + " related:resources ", '').split(' ');
    }
    else {
        searchTokens = searchText.replace(search[0] + " ", '').split(' ');
    }
    var keywords = searchTokens.filter(function (token) { return token !== '' && token.indexOf(':') < 0; });
    var filters = searchTokens.filter(function (token) { return token.indexOf(':') >= 0; })
        .map(function (f) {
        var _a, _b;
        var property;
        var values;
        // This will allow the search to return the clusterrolebinding resources
        if (f.includes('name:system:') || f.includes('name:icp:')) {
            _a = __read(f.split('name:'), 2), property = _a[0], values = _a[1];
            property = 'name';
        }
        else {
            _b = __read(f.split(':'), 2), property = _b[0], values = _b[1];
        }
        return { property: property, values: values.split(',') };
    })
        .filter(function (f) { return ['', '=', '<', '>', '<=', '>=', '!=', '!'].findIndex(function (op) { return op === f.values[0]; }) === -1; });
    return { keywords: keywords, filters: filters };
};
